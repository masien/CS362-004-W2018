Nick Masie
CS 362
3/5/18

Assignment 5

Bug Report: Find and report at least two (2) bugs.  Did you find any interesting bugs using your tests, explain why in some details? Also, explain in some details about the bug(s), such as the cause, how you found it, etc.?

As alluded to above in the “Test-Report” section, the two bugs that I found in my teammate’s refactored dominion code were: 1) in the executeAdventurer() function, where the function caused the player to potentially draw a smithy card and count that smithy card as a treasure card instead of just copper, silver, and gold, and 2) in the executeSmithy() function, where the function caused the player to draw four cards instead of only three cards like the card/rules state.

When analyzing the results of randomtestadventurer.c (adventurer test), it actually took a little bit of time and determination to find a bug in the results here because it seemed that the random adventurer test would pass for a large majority of the iterations, but I would occasionally find one case here and there where it would fail, so I knew something had to be going on and that this may have been a potential bug.  Using the debugging tool in my IDE, I tried to first step through a test that passed in order to see if the variables (mainly the values of the cards in the player’s hand in relation to the treasure count) were what I was expecting, and everything seemed to be correct.  However, when I stepped through a test that failed, I found that some of the variables were not what I was expecting.  I found that despite the treasure count being increased, the player’s hand was not actually gaining the two treasure cards that it should have been.  After analyzing the hands of the player in the cases where this error was occurring a little more closely, I noticed that every hand that would fail my random adventurer test in this way would draw a new smithy card into the hand, which indicated that smithy may be counted as a treasure card for some reason.  This caused me to go back and analyze my teammates executeAdventurer() function, and sure enough on line 649, I found that copper, silver, gold, and smithy were all being counted as treasure cards, when of course smithy is not a treasure card.  This caused my two separate cases of the actual game state and my test game state and their respective treasure counts to disagree, so this is when I knew I had found my bug (or at least one of them) in the refactored executeAdventurer() function.  This bug is not as severe as the one in the executeSmithy() function described below because it has a much lower chance of occurring as it only happens when the player happens to stumble upon and reveal a smithy card from the deck, but nonetheless it can still have an inappropriate outcome and affect the game.

The analysis of the randomtestcard2.c (smithy test) results proved to be much simpler and quicker than that of randomtestadventurer.c (adventurer test).  My test for smithy actually failed every single time, and I will soon describe why.  One of my main tests for this smithy was to simply check to see if the player had successfully drawn three cards into the player’s hand.  The way I tested this was simply to compare the hand counts of the player’s hand in the actual game state versus my test game state.  If there was a net gain of two cards in the player’s hand count in the test game state (minus one to discard the smithy card, and plus three for the three cards drawn, for a net gain of three minus one to equal two), then the test should pass, but obviously this was not the case.  Using my debugger and print statements to check the values of the player’s hand such as the hand count and the actual cards that were in the player’s hand, I found that there was a net gain of three every single time.  After examining my test code to make sure it was logical and correct, and running it against my the original dominion code to ensure that it would pass against code that I knew to be correct, I had a suspicion that I may have found my bug in the refactored executeSmithy() function.  This was when I went back to the executeSmithy() function in dominion.c, and sure enough after examining the code, I found that the executeSmithy() function was actually causing the player to draw four cards instead of three due to the number of iterations in the for-loop on line 673, which caused the call to the drawCard() function on line 675 to be called four times instead of three, so this is when I knew that I had found my bug (or at least one of them) in the refactored executeSmithy() function.  This bug is obviously much more critical and severe compared to the bug found in the executeAdventurer() function described above because it happens every single time the smithy card is played, thus rendering the smithy card to have an unfair advantage every time that it was played, which has a much bigger effect on the game compared to the bug in the executeAdventurer() function.

In order to reproduce the bug in the executeAdventurer() function, one simply needs to use the debugger to step through a particular game state situation where a player uses an adventurer card, reveals cards from their deck until they find two treasure cards, and reveals a smithy card before two actual treasure cards are revealed.  While stepping through the debugger as this game state situation occurs, one should notice that when a smithy card is revealed, the drawntreasure counter increments.  The rule of the adventurer card is “Reveal cards from your deck until you reveal 2 treasure cards.  Put those Treasure cards into your hand and discard the other revealed cards,” where these treasure cards should only be copper, silver, and gold.  This means that we should expect only those three cards (copper, silver, and gold) to increment the drawntreasure counter, and the player should now have two new treasure cards in the hand, but obviously we see this is not the case in this particular game state situation.  Stepping through the debugger, we see that smithy also increments the drawntreasure counter, and the player does not actually get two new treasure cards because smithy is now mistakenly counted as a treasure card.  The way to fix this bug would be to go back into the refactored executeAdventurer() function in dominion.c, and change the code on line 656 in the if statement conditions to only include copper, silver, and gold.  In other words, we need to remove the “|| cardDrawn = smithy” code from that conditional statement so that smithy does not increment the drawntreasure counter in the line below (line 657).  After implementing this fix, the values in the debugger (mainly drawntreasure counter) and the function in general should be functioning properly.

In order to reproduce the bug in the executeSmithy() function, one simply needs to use the debugger to step through literally any game state situation where a player uses the smithy card, as the function should fail just about any and every test due to the bug that was introduced.  While stepping through the debugger in virtually any game state with a smithy card, one should notice that when a smithy card is played, the player’s hand count increases by one more than it should.  The rule of the smithy card is “+3 cards,” so this means that we should expect there to be a net gain of two cards in the player’s hand (minus one for the played smithy card, and plus three for the effect of the smithy card, so three minus one equals two), but obviously this is not the case currently.  Stepping through the debugger, we see that the handCount value of the current player in the game state has a net gain of three cards because the bug in the refactored executeSmithy() function causes the player to draw four cards instead of three.  The reason for this bug is because the for-loop counter inside of the executeSmithy() function on line 673 is set to 4 instead of 3, so way to fix this bug would be to simply change the for-loop counter from “i < 4” to “i < 3” so that the call to the todrawCard() function on line 675 is only executed three times instead of four.  After implementing this fix, the values in the debugger (mainly handCount) and the function in general should be functioning properly.
