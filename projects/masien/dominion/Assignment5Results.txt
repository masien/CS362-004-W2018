Nick Masie
CS 362
3/5/18

Assignment 5

Test Report: Describe your experience testing Dominion.  Document in detail, including code coverage information, the status and your view of the reliability of the Dominion code of your teammate.

Overall, my experience testing my teammate’s dominion.c code was fairly simple and straight-forward.  I ran all of my unit tests, card tests, and random card tests, but only my randomtestadventuer.c (adventurer) and randomcardtest2.c (smithy) tests found two bugs total that I will describe below in this document.  Essentially, all that I had to do was replace my own dominion.c file with my teammate’s dominon.c file, and then I simply observed and studied the differences between our two files such as which functions he refactored, how he refactored them, the difference in parameters and methods of calling the functions within the tests, making sure that the tests compiled, ran, and correctly called the cardEffect() function, making sure that the test results were logical, accurate, and what I would expect, etc.  I believe these are all of the basic things that almost every student would have to do in this assignment, and surprisingly I did not have much trouble getting everything to work like it did in previous assignments other than slightly changing the way that my tests called the cardEffect() function and making sure that my Makefile was still properly functioning.  My teammate kept the parameters and the method of calling the cardEffect() function exactly the same, which in turn calls the refactored “executeAdventurer()” and “executeSmithy()” functions essentially exactly the same as it normally would in the original dominion code other than inserting his refactored functions with their relevant/required parameters into the switch statements inside cardEffect(), so this made the whole process very simple, straight-forward, reliable, and maintainable from test to test.  I decided to focus on and test my teammate’s adventurer and smithy functions because I had already written successful tests for those functions in the previous assignments, and those were the tests of mine that actually found bugs that my teammate introduced.  I focused on randomtestadventurer.c (adventurer) and randomtestcard2.c (smithy) over the regular card tests because in my previous analysis of all of the test functions in previous assignments, these random tests seemed to be the most rigorous, thorough, possess the most code coverage, create the most possibilities, etc., and thus most capable and likely to catch any bugs that my teammate may have introduced. 

As mentioned above, I tested my teammate’s executeAdventurer() and executeSmithy() functions in my teammate’s refactored code of dominion, and I was able to find one bug in each of these functions/tests.  The parameters that my teammate passed into his refactored executeAdventurer() function were int currentPlayer, struct gameState *state, int drawntreasure, int temphand[], int z, int cardDrawn.  The parameters that my teammate passed into his refactored executeSmithy() function were int currentPlayer, struct gameState *state, int handPos.  While the parameters of these refactored functions are different, they had no effect on how I called the cardEffect() function in my tests as my teammate kept the parameters of the cardEffect() function exactly the same, and passed only the necessary variables/parameters that were needed in each refactored function.  This means that I literally only had to change one line in my tests, which was the line that called the cardEffect() function, and then everything worked perfectly on the first try.  I believe the fact that I only had to slightly change the parameters around in one function call on one line, which was arguably more or less exactly the same as I had done in my own code, speaks volumes about the maintainability in my own tests/code as well as my teammate’s refactored dominion code.  Maintainability is all about how easy it is to adapt and change code as needed to perform the desired function, and my experience and results prove that my tests/code as well as my teammate’s refactored dominion code are highly maintainable in this case.

After completing the adaptation and maintenance of my tests in relation to my teammate’s dominion code, I was able to compile and run the tests, and then analyze the results.  Using only my two tests of randomtestadventurer.c (adventurer) and randomtestcard2.c (smithy), I was able to find one bug in each of the refactored executeAdventurer() and executeSmithy() functions.

The code coverage of the random test for the adventurer card (randomtestadventurer.c) was 93.55%, which is actually an ever so slight increase from the 93.44% code coverage that I got for assignment 4, which is a 0.11% increase.  As mentioned before, my teammate’s dominion code within the switch statement of the cardEffect() function was much more similar to the original dominion code than my own refactored version of the dominion code, so that may explain the ever so slight increase in code coverage.

The code coverage of the random test for the smithy card (randomtestcard2.c) was 93.48%, which is also an ever so slight increase from the 93.33% code coverage that I got for assignment 4, which is a 0.15% increase.  As mentioned before, my teammate’s dominion code within the switch statement of the cardEffect() function was much more similar to the original dominion code than my own refactored version of the dominion code, so that may explain the ever so slight increase in code coverage.

The code coverage of the random test for the steward card (randomtestcard1.c) was 87.84%.

The code coverage of the unit test for the steward card (cardtest1.c) was 88.46%, which was a slight increase of 0.22% from the 88.24% code coverage that I got in assignment 3.

The code coverage of the unit test for the adventurer card (cardtest2.c) was 90.91%, which was a slight increase of 0.21% from the 90.70% code coverage that I got in assignment 3.  This test of mine actually did not catch the bug that my teammate introduced into the executeAdventurer() function because I did not hard code in a game state situation that involved the smithy card, but due to the randomization in my randomtestadventurer.c test, I happened to stumble upon a game state situation that involved the smithy card and thus revealed the bug.

The code coverage of the unit test for the feast card (cardtest3.c) was 95.00%, which was a slight increase of 0.13% from the 94.87% code coverage that I got in assignment 3.

The code coverage of the unit test for the smithy card (cardtest4.c) was 92.11%, which was a slight increase of 0.22% from the 91.89% code coverage that I got in assignment 3.

The code coverage of the unit test for the isGameOver() function (unittest1.c) was 81.43%, which was a slight increase of 0.27% from the 81.16% code coverage that I got in assignment 3.

The code coverage of the unit test for the getCost() function (unittest2.c) was 72.46%, which was a slight increase of 0.13% from the 72.33% code coverage that I got in assignment 3.

The code coverage of the unit test for the supplyCount() function (unittest3.c) was 90.00%, which was a slight increase of 0.34% from the 89.66% code coverage that I got in assignment 3.

The code coverage of the unit test for the updateCoins() function (unittest4.c) was 95.95%, which was a slight increase of 0.06% from the 95.89% code coverage that I got in assignment 3.

The code coverage of the entire dominion.c file was 28.85%, which was an increase of 8.41% from the 20.44% code coverage that I got in assignment 3.  I believe that this bigger increase in code coverage is due to the fact that I have more tests running in assignment 5 compared to assignment 3, but this could also be a testament to the higher reliability of my teammate’s refactored dominon.c code in comparison to that of my own in assignment 3.  This would also explain the slight increase in code coverage in every single test that I ran on my teammate’s refactored dominion.c code in comparison to that of my own in assignment 3.

Many of the tests involving the a situation where a card was played and should be discarded (such as the card tests) failed due to what I believe is a bug in original dominion.c code, which I believe is due to the fact that the cardEffect() function does not properly call the discardCard() function for many of the cards inside of the big switch statement when I believe that it should in these cases.  This causes the tests to fail and may indicate a bug, and correctly so, but I believe that this bug lies in the original code and not my teammate’s code because this same bug occurred in my own dominion.c code in previous assignments.  I discussed this bug with the rest of my group, and most of us agreed that this was strange and maybe even buggy behavior for the original code, but another student from another group brought up the fact that we may not fully understand the rules of the game and how the discardCard() function is supposed to work in terms of the discard pile and trash pile, so I will simply make a note of that bug here and focus solely on my teammate’s introduced bugs for this assignment 5.  Other than this bug, which causes the test failures that you may notice when running all of the tests, none of my tests caught any bugs other than the adventurer and smithy card tests.

Debugging: Document the process of identifying and fixing a bug in your own code, and mention your code changes.  You may start with a bug report from a teammate or from your own testing.  Show how you used a debugger (e.g., GDB, or another debugger tool) to understand and debug your code.

Other than knowing about the bugs beforehand that I introduced into adventurer, smithy, steward, and remodel in assignment 2, my test results from the unit card tests in assignment 3 and the random card tests in assignment 4 would be what would initially indicate that there were bugs in my own dominon.c code.  All four card tests achieved a code coverage of roughly 88% or higher, so although I wasn’t able to achieve 100%, I was still fairly confident in the results that they provided.  The random tests tended to achieve a higher code coverage, but there were four unit card tests and only 3 random card tests, so in this debugging section I will focus on the four unit card tests because all of the tests successfully identified the same exact bugs that I introduced. 

When analyzing the results of cardtest1.c (steward unit test), I found that if the player tried to choose choice 2 for the steward card (plus 2 coins), then that would never happen and the player would actually be forced to choose choice 3 (trash 2 cards in the hand).  This happened every single time that the player played steward and chose choice 2, so this was a strong clue to use the debugger to check the value of choice particular choice variable to make sure that it was 2 and not 3.  Interestingly, the value for the choice variable was indeed 2, so I went to the playStewardCard() function in my own dominon.c code and stepped through the debugger to see that even though my choice variable was 2, the if “else if” conditional else if statement on line 692 was never actually triggered because it was written as “else if (choice == 5)” instead of “else if “(choice == 2).”  Obviously the simple fix for this bug would be to change that 5 back to a 2 so that the conditional else if statement is properly triggered.

When analyzing the results of cardtest2.c (adventurer unit test), I found that every single time the player would play an adventurer card, the player would only draw one treasure card instead of two.  Because this happened every single time, this was a strong clue that there may be a critical bug involving the drawntreasure variable, which counts how many treasure cards the player has revealed and drawn from the deck during that turn, so this is the variable I focused on when stepping through the code with my debugger.  Sure enough, I found that the debugger was showing that the value of drawntreasure would only ever reach a value of 1 before terminating, so there has to be some sort of bug affecting the drawntreasure variable in the dominion.c code.  When I went back and stepped through the playAdventurerCard() function in the dominion.c code with my debugger and closely analyzed what each line was doing, I realized that the while condition on line 468 was set to “while(drawntreasure<1)” instead of  “while(drawntreasure<2).”  Obviously the simple fix for this bug would be to change that 1 back to a 2 so that the while condition terminated at the appropriate time according to the rules of the adventurer card.

When analyzing the results of cardtest3.c (feast unit test), it took a little bit of digging to actually discover the bug, but if you attempt to use each of the card possibilities when playing feast (in other words, try to gain any card with a cost up to 5), then you will notice that only cards costing up to 3 work pass the test, and any cards with a value of 4 or greater will fail.  This is an obvious indication that something must be wrong with the getCost() function or perhaps a conditional statement using the getCost() function.  When stepping through the debugger in the test and dominon.c code, I found that the getCost() function was returning the correct values for each card, and as described above in the “Test Report” section, the getCost() function’s unit test passed all of its test cases, so this led me to believe that there must be a bug in dominion.c in terms of how getCost() is used.  Sure enough, when I stepped through dominion.c with the debugger, I found that the call to the updateCoins() function on line 818 was using the value of 3 coins as a parameter instead of a value of 5 coins like the rules should state.  Also described in the “Test Report” section above, the updateCoins() function’s unit tests passed all of its test cases as well, so clearly there is no bug in the updateCoins() function but rather the bug lies in the dominion.c code inside the feast switch statement case where the updateCoins() function is called.  Obviously the simple fix for this bug would be to change that 3 back to a 5 so that the player actually has the full 5 coins available to use to purchase a card rather than only 3 coins, which obviously limited the player’s choices of cards to buy much more than it should have.

When analyzing the results of cardtest4.c (smithy unit test), I found that every single time that a player used the smithy card, the test would fail because they seemed to be gaining 5 cards rather than only 3 like the rules of the game state.  Because this happened every single time smithy was played, this was a strong clue that there must be a critical bug in the playSmithyCard() function in the dominion.c code.  When stepping through my test with the debugger, the player’s hand clearly gained 2 extra cards than should be there, so when I stepped through the playSmithyCard() function in the dominion.c code, I found that the for-loop on line 673 and therefore the drawCard() function on line 675 was executing 5 times instead of 3 times.  This explains why the player was gaining 2 extra cards every time the smithy card was played.  Obviously, the simple fix for this bug would be to change the for-loop counter from a 5 back to a 3 so that the player only draws 3 cards like the rules of the game state.

Bug Report: Find and report at least two (2) bugs.  Did you find any interesting bugs using your tests, explain why in some details? Also, explain in some details about the bug(s), such as the cause, how you found it, etc.?

As alluded to above in the “Test-Report” section, the two bugs that I found in my teammate’s refactored dominion code were: 1) in the executeAdventurer() function, where the function caused the player to potentially draw a smithy card and count that smithy card as a treasure card instead of just copper, silver, and gold, and 2) in the executeSmithy() function, where the function caused the player to draw four cards instead of only three cards like the card/rules state.

When analyzing the results of randomtestadventurer.c (adventurer test), it actually took a little bit of time and determination to find a bug in the results here because it seemed that the random adventurer test would pass for a large majority of the iterations, but I would occasionally find one case here and there where it would fail, so I knew something had to be going on and that this may have been a potential bug.  Using the debugging tool in my IDE, I tried to first step through a test that passed in order to see if the variables (mainly the values of the cards in the player’s hand in relation to the treasure count) were what I was expecting, and everything seemed to be correct.  However, when I stepped through a test that failed, I found that some of the variables were not what I was expecting.  I found that despite the treasure count being increased, the player’s hand was not actually gaining the two treasure cards that it should have been.  After analyzing the hands of the player in the cases where this error was occurring a little more closely, I noticed that every hand that would fail my random adventurer test in this way would draw a new smithy card into the hand, which indicated that smithy may be counted as a treasure card for some reason.  This caused me to go back and analyze my teammates executeAdventurer() function, and sure enough on line 649, I found that copper, silver, gold, and smithy were all being counted as treasure cards, when of course smithy is not a treasure card.  This caused my two separate cases of the actual game state and my test game state and their respective treasure counts to disagree, so this is when I knew I had found my bug (or at least one of them) in the refactored executeAdventurer() function.  This bug is not as severe as the one in the executeSmithy() function described below because it has a much lower chance of occurring as it only happens when the player happens to stumble upon and reveal a smithy card from the deck, but nonetheless it can still have an inappropriate outcome and affect the game.

The analysis of the randomtestcard2.c (smithy test) results proved to be much simpler and quicker than that of randomtestadventurer.c (adventurer test).  My test for smithy actually failed every single time, and I will soon describe why.  One of my main tests for this smithy was to simply check to see if the player had successfully drawn three cards into the player’s hand.  The way I tested this was simply to compare the hand counts of the player’s hand in the actual game state versus my test game state.  If there was a net gain of two cards in the player’s hand count in the test game state (minus one to discard the smithy card, and plus three for the three cards drawn, for a net gain of three minus one to equal two), then the test should pass, but obviously this was not the case.  Using my debugger and print statements to check the values of the player’s hand such as the hand count and the actual cards that were in the player’s hand, I found that there was a net gain of three every single time.  After examining my test code to make sure it was logical and correct, and running it against my the original dominion code to ensure that it would pass against code that I knew to be correct, I had a suspicion that I may have found my bug in the refactored executeSmithy() function.  This was when I went back to the executeSmithy() function in dominion.c, and sure enough after examining the code, I found that the executeSmithy() function was actually causing the player to draw four cards instead of three due to the number of iterations in the for-loop on line 673, which caused the call to the drawCard() function on line 675 to be called four times instead of three, so this is when I knew that I had found my bug (or at least one of them) in the refactored executeSmithy() function.  This bug is obviously much more critical and severe compared to the bug found in the executeAdventurer() function described above because it happens every single time the smithy card is played, thus rendering the smithy card to have an unfair advantage every time that it was played, which has a much bigger effect on the game compared to the bug in the executeAdventurer() function.

In order to reproduce the bug in the executeAdventurer() function, one simply needs to use the debugger to step through a particular game state situation where a player uses an adventurer card, reveals cards from their deck until they find two treasure cards, and reveals a smithy card before two actual treasure cards are revealed.  While stepping through the debugger as this game state situation occurs, one should notice that when a smithy card is revealed, the drawntreasure counter increments.  The rule of the adventurer card is “Reveal cards from your deck until you reveal 2 treasure cards.  Put those Treasure cards into your hand and discard the other revealed cards,” where these treasure cards should only be copper, silver, and gold.  This means that we should expect only those three cards (copper, silver, and gold) to increment the drawntreasure counter, and the player should now have two new treasure cards in the hand, but obviously we see this is not the case in this particular game state situation.  Stepping through the debugger, we see that smithy also increments the drawntreasure counter, and the player does not actually get two new treasure cards because smithy is now mistakenly counted as a treasure card.  The way to fix this bug would be to go back into the refactored executeAdventurer() function in dominion.c, and change the code on line 656 in the if statement conditions to only include copper, silver, and gold.  In other words, we need to remove the “|| cardDrawn = smithy” code from that conditional statement so that smithy does not increment the drawntreasure counter in the line below (line 657).  After implementing this fix, the values in the debugger (mainly drawntreasure counter) and the function in general should be functioning properly.

In order to reproduce the bug in the executeSmithy() function, one simply needs to use the debugger to step through literally any game state situation where a player uses the smithy card, as the function should fail just about any and every test due to the bug that was introduced.  While stepping through the debugger in virtually any game state with a smithy card, one should notice that when a smithy card is played, the player’s hand count increases by one more than it should.  The rule of the smithy card is “+3 cards,” so this means that we should expect there to be a net gain of two cards in the player’s hand (minus one for the played smithy card, and plus three for the effect of the smithy card, so three minus one equals two), but obviously this is not the case currently.  Stepping through the debugger, we see that the handCount value of the current player in the game state has a net gain of three cards because the bug in the refactored executeSmithy() function causes the player to draw four cards instead of three.  The reason for this bug is because the for-loop counter inside of the executeSmithy() function on line 673 is set to 4 instead of 3, so way to fix this bug would be to simply change the for-loop counter from “i < 4” to “i < 3” so that the call to the todrawCard() function on line 675 is only executed three times instead of four.  After implementing this fix, the values in the debugger (mainly handCount) and the function in general should be functioning properly.

